[{"filePath":"/repo/veda-client/src/Backend.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/BackendError.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/Effect.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/Emitter.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/Model.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'oldValue' is defined but never used.","line":69,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":69,"endColumn":43,"suggestions":[{"messageId":"removeVar","data":{"varName":"oldValue"},"fix":{"range":[2238,2248],"text":""},"desc":"Remove unused variable 'oldValue'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Emitter from './Emitter.js';\nimport Backend from './Backend.js';\nimport WeakCache from './WeakCache.js';\nimport Subscription from './Subscription.js';\nimport Value from './Value.js';\nimport {genUri, decorator} from './Util.js';\nimport {reactive} from './Reactive.js';\n\nconst IS_NEW = Symbol('isNew');\nconst IS_SYNC = Symbol('isSync');\nconst IS_LOADED = Symbol('isLoaded');\nconst LOAD_PROMISE = Symbol('loadPromise');\nconst SAVE_PROMISE = Symbol('savePromise');\nconst RESET_PROMISE = Symbol('resetPromise');\nconst REMOVE_PROMISE = Symbol('removePromise');\nconst MEMBERSHIPS = Symbol('memberships');\nconst RIGHTS = Symbol('rights');\n\nexport default class Model extends Emitter(Object) {\n  static cache = new WeakCache();\n\n  constructor (data) {\n    super();\n\n    // Setup modified listener that marks model as not sync\n    // Note: For cached models returning early, this listener is already attached\n    // from the first construction, so we don't duplicate it\n    this.on('modified', () => this.isSync(false));\n\n    if (typeof data === 'string') {\n      this.id = data;\n      this.isNew(false);\n      this.isSync(false);\n      this.isLoaded(false);\n\n      // Check cache - return cached proxy if exists\n      const cached = Model.cache.get(this.id);\n      if (cached) {\n        return cached; // Already reactive and has listener\n      }\n    } else if (typeof data === 'undefined' || data === null) {\n      this.id = genUri();\n      this.isNew(true);\n      this.isSync(false);\n      this.isLoaded(false);\n    } else if (typeof data === 'object') {\n      const id = data['@'];\n      const cached = Model.cache.get(id);\n\n      if (cached) {\n        // Update cached model with new data\n        // No need to reattach listener - already attached from first construction\n        cached.apply(data);\n        cached.isNew(false);\n        cached.isSync(true);\n        cached.isLoaded(true);\n        return cached; // Already reactive and has listener\n      }\n\n      this.id = id;\n      this.apply(data);\n      this.isNew(false);\n      this.isSync(true);\n      this.isLoaded(true);\n    }\n\n    // Make the model reactive with emit events for backward compatibility\n    const reactiveModel = reactive(this, {\n      onSet: function(key, value, oldValue) {\n        // Emit events for backward compatibility\n        this.emit(key, value);\n        this.emit('modified', key, value);\n      },\n      onDelete: function(key) {\n        // Emit events for backward compatibility\n        this.emit(key);\n        this.emit('modified', key);\n      }\n    });\n\n    // Cache the reactive proxy\n    Model.cache.set(this.id, reactiveModel);\n\n    return reactiveModel;\n  }\n\n  apply (data) {\n    const thisProps = new Set(Object.getOwnPropertyNames(this));\n    const dataProps = new Set(Object.getOwnPropertyNames(data));\n\n    const propsToDelete = [...thisProps].filter(prop => !dataProps.has(prop));\n    propsToDelete.forEach(prop => prop !== 'id' && delete this[prop]);\n\n    dataProps.forEach((prop) => {\n      if (prop === '@') return this.id = data['@'] ?? genUri();\n      let value = data[prop];\n      if (Array.isArray(value)) {\n        value = value.map(Value.parse);\n      } else {\n        value = Value.parse(value);\n      }\n      this[prop] = value;\n    });\n  }\n\n  toJSON () {\n    const keys = Object.getOwnPropertyNames(this);\n    const json = keys.reduce((acc, key) => {\n      if (key === 'id') {\n        acc['@'] = this.id;\n        return acc;\n      }\n      const value = this[key];\n      if (Array.isArray(value)) {\n        acc[key] = value.map(Value.serialize).filter(Boolean);\n        if (!acc[key].length) delete acc[key];\n      } else {\n        acc[key] = [Value.serialize(value)].filter(Boolean);\n        if (!acc[key].length) delete acc[key];\n      }\n      return acc;\n    }, {});\n    return json;\n  }\n\n  toString () {\n    return this.id;\n  }\n\n  subscribe () {\n    const updater = (id) => {\n      const model = new Model(id);\n      model.reset().catch((error) => {\n        // Note: This error handler is difficult to test without real WebSocket messages\n        // It's triggered when the server sends an update for a model that fails to load\n        // Coverage: Tested manually in production, but hard to mock in unit tests\n        console.error(`Error resetting model ${id}`, error);\n      });\n    };\n    Subscription.subscribe(this, [this.id, this.hasValue('v-s:updateCounter') ? this['v-s:updateCounter'][0] : 0, updater]);\n  }\n\n  unsubscribe () {\n    Subscription.unsubscribe(this.id);\n  }\n\n  isNew (value) {\n    return typeof value === 'undefined' ? this[IS_NEW] : this[IS_NEW] = !!value;\n  }\n\n  isSync (value) {\n    return typeof value === 'undefined' ? this[IS_SYNC] : this[IS_SYNC] = !!value;\n  }\n\n  isLoaded (value) {\n    return typeof value === 'undefined' ? this[IS_LOADED] : this[IS_LOADED] = !!value;\n  }\n\n  hasValue (prop, value) {\n    if (!prop && typeof value !== 'undefined') {\n      return Object.getOwnPropertyNames(this).reduce((prev, prop) => prev || this.hasValue(prop, value), false);\n    }\n    let found = !!(typeof this[prop] !== 'undefined');\n    if (typeof value !== 'undefined' && value !== null) {\n      const serialized = Value.serialize(value);\n      let propValue = this[prop];\n      if (propValue instanceof Function) return false;\n      propValue = Array.isArray(propValue) ? propValue : [propValue];\n      found = found && propValue.some((item) => serialized.isEqual(Value.serialize(item)));\n    }\n    return found;\n  }\n\n  addValue (prop, value) {\n    if (!this.hasValue(prop)) {\n      this[prop] = value;\n    } else {\n      const currentValue = this[prop];\n      if (Array.isArray(currentValue)) {\n        this[prop] = [...currentValue, value];\n      } else {\n        this[prop] = [currentValue, value];\n      }\n    }\n  }\n\n  removeValue (prop, value) {\n    if (!prop && typeof value !== 'undefined') {\n      return Object.getOwnPropertyNames(this).forEach((prop) => this.removeValue(prop, value));\n    }\n    if (this.hasValue(prop, value)) {\n      if (Array.isArray(this[prop])) {\n        const serializedValue = Value.serialize(value);\n        this[prop] = this[prop].filter((item) => !serializedValue.isEqual(Value.serialize(item)));\n        if (!this[prop].length) delete this[prop];\n      } else {\n        delete this[prop];\n      }\n    }\n  }\n\n  async getPropertyChain (...props) {\n    await this.load();\n    const prop = props.shift();\n    if (!this.hasValue(prop)) return;\n    if (!props.length) return this[prop];\n    const next = Array.isArray(this[prop]) ? this[prop][0] : this[prop];\n    return next.getPropertyChain(...props);\n  }\n\n  async load (cache = true) {\n    if (this[LOAD_PROMISE]) {\n      return this[LOAD_PROMISE];\n    }\n\n    if (this.isNew() || this.isLoaded() && cache) {\n      return this;\n    }\n\n    this[LOAD_PROMISE] = (async () => {\n      try {\n        const data = await Backend.get_individual(this.id, cache);\n        this.apply(data);\n        this.isNew(false);\n        this.isSync(true);\n        this.isLoaded(true);\n        return this;\n      } finally {\n        this[LOAD_PROMISE] = null;\n      }\n    })();\n\n    return this[LOAD_PROMISE];\n  }\n\n  async reset () {\n    if (this[RESET_PROMISE]) {\n      return this[RESET_PROMISE];\n    }\n\n    this[RESET_PROMISE] = (async () => {\n      try {\n        await this.load(false);\n        return this;\n      } finally {\n        this[RESET_PROMISE] = null;\n      }\n    })();\n\n    return this[RESET_PROMISE];\n  }\n\n  async save () {\n    if (this[SAVE_PROMISE]) {\n      return this[SAVE_PROMISE];\n    }\n\n    if (this.isSync()) return this;\n\n    this[SAVE_PROMISE] = (async () => {\n      try {\n        const json = this.toJSON();\n        await Backend.put_individual(json);\n        this.isNew(false);\n        this.isSync(true);\n        this.isLoaded(true);\n        return this;\n      } finally {\n        this[SAVE_PROMISE] = null;\n      }\n    })();\n\n    return this[SAVE_PROMISE];\n  }\n\n  async remove () {\n    if (this[REMOVE_PROMISE]) {\n      return this[REMOVE_PROMISE];\n    }\n\n    this[REMOVE_PROMISE] = (async () => {\n      try {\n        await Backend.remove_individual(this.id);\n        this.isNew(true);\n        this.isSync(false);\n        this.isLoaded(false);\n        return this;\n      } finally {\n        this[REMOVE_PROMISE] = null;\n      }\n    })();\n\n    return this[REMOVE_PROMISE];\n  }\n\n  toLabel (prop=\"rdfs:label\", lang = ['RU']) {\n    if (!this.hasValue(prop)) return '';\n    let label = '';\n    if (this[prop].length == 1) {\n      label = this[prop][0];\n    } else {\n      label = this[prop].filter((l) => {\n        for (const currentLang of lang) {\n          const re = new RegExp('\\\\^\\\\^' + currentLang);\n          if (re.test(l)) return true;\n        }\n        return false;\n      }).join(' ');\n    }\n    return label.replace(/\\^\\^../g, \"\");\n  }\n\n  async loadMemberships () {\n    const membershipJSON = await Backend.get_membership(this.id);\n    membershipJSON['@'] = genUri();\n    this[MEMBERSHIPS] = new Model(membershipJSON);\n    return this[MEMBERSHIPS];\n  }\n\n  async isMemberOf (id) {\n    if (!this[MEMBERSHIPS]) await this.loadMemberships();\n    return this[MEMBERSHIPS].hasValue('v-s:memberOf', id);\n  }\n\n  async loadRight () {\n    if (this[RIGHTS]) return this[RIGHTS];\n    if (this.isNew()) {\n      this[RIGHTS] = new Model();\n      this[RIGHTS]['v-s:canCreate'] = [true];\n      this[RIGHTS]['v-s:canRead'] = [true];\n      this[RIGHTS]['v-s:canUpdate'] = [true];\n      this[RIGHTS]['v-s:canDelete'] = [true];\n    } else {\n      const rightsJSON = await Backend.get_rights(this.id, Backend.user_uri);\n      rightsJSON['@'] = genUri();\n      this[RIGHTS] = new Model(rightsJSON);\n    }\n    return this[RIGHTS];\n  }\n\n  async canCreate () {\n    await this.loadRight();\n    return this[RIGHTS].hasValue('v-s:canCreate', true);\n  }\n\n  async canRead () {\n    await this.loadRight();\n    return this[RIGHTS].hasValue('v-s:canRead', true);\n  }\n\n  async canUpdate () {\n    await this.loadRight();\n    return this[RIGHTS].hasValue('v-s:canUpdate', true);\n  }\n\n  async canDelete () {\n    await this.loadRight();\n    return this[RIGHTS].hasValue('v-s:canDelete', true);\n  }\n}\n\n['load', 'save', 'reset', 'remove'].forEach((action) => Model.prototype[action] = actionDecorator(Model.prototype[action]));\n\nfunction actionDecorator (fn) {\n  async function pre () {\n    const before = this.toJSON();\n    await this.emit('before' + fn.name, before);\n  };\n  async function post () {\n    const after = this.toJSON();\n    await this.emit('after' + fn.name, after);\n  };\n  return decorator(fn, pre, post);\n}\n","usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/Observable.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/Reactive.js","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'no-unused-expressions').","line":167,"column":5,"severity":1,"nodeType":null,"fix":{"range":[4966,5015],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import {effect, track, trigger} from './Effect.js';\n\n// WeakMap to store already wrapped reactive objects\nconst reactiveMap = new WeakMap();\n\n/**\n * Creates a reactive proxy that tracks property access and triggers updates\n * @param {Object} target - The object to make reactive\n * @param {Object} options - Options for reactive behavior\n * @param {Function} options.onSet - Callback when property is set\n * @param {Function} options.onDelete - Callback when property is deleted\n * @returns {Proxy} - Reactive proxy object\n */\nexport function reactive(target, options = {}) {\n  if (typeof target !== 'object' || target === null) {\n    return target;\n  }\n\n  // Don't wrap already reactive objects\n  if (target.__isReactive) {\n    return target;\n  }\n\n  // Check if we already wrapped this object (prevents circular references)\n  const existingProxy = reactiveMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n\n  const handler = {\n    get(target, key, receiver) {\n      // Special marker for reactive detection\n      if (key === '__isReactive') {\n        return true;\n      }\n\n      // Track this property access\n      track(target, key);\n\n      const value = Reflect.get(target, key, receiver);\n\n      // Bind functions to maintain correct context\n      if (typeof value === 'function') {\n        // For arrays, wrap mutation methods to trigger reactivity\n        if (Array.isArray(target)) {\n          const mutationMethods = ['push', 'pop', 'shift', 'unshift', 'splice'];\n          const sortingMethods = ['sort', 'reverse'];\n\n          // Methods that always modify array\n          if (mutationMethods.includes(key)) {\n            return function(...args) {\n              const result = value.apply(target, args);\n              // Trigger all effects that access any property of this array\n              trigger(target, null, true);\n              return result;\n            };\n          }\n\n          // Methods that may or may not modify (sort, reverse)\n          // Only trigger if array actually changed\n          if (sortingMethods.includes(key)) {\n            return function(...args) {\n              // Snapshot array before operation\n              const before = [...target];\n              const result = value.apply(target, args);\n\n              // Check if array actually changed\n              const changed = before.length !== target.length ||\n                             before.some((val, idx) => val !== target[idx]);\n\n              if (changed) {\n                trigger(target, null, true);\n              }\n\n              return result;\n            };\n          }\n        }\n        return value.bind(target);\n      }\n\n      // Deep reactivity - wrap nested objects\n      // But skip Promises, Dates, and other special objects\n      if (typeof value === 'object' && value !== null) {\n        // Don't wrap Promise, Date, RegExp, etc\n        if (value instanceof Promise || value instanceof Date || value instanceof RegExp) {\n          return value;\n        }\n        return reactive(value, options);\n      }\n\n      return value;\n    },\n\n    set(target, key, value, receiver) {\n      const oldValue = target[key];\n      const result = Reflect.set(target, key, value, receiver);\n\n      // Only trigger if value actually changed\n      if (oldValue !== value) {\n        trigger(target, key);\n\n        // Call custom onSet handler if provided\n        if (options.onSet && typeof key !== 'symbol') {\n          options.onSet.call(target, key, value, oldValue);\n        }\n      }\n\n      return result;\n    },\n\n    deleteProperty(target, key) {\n      const hadKey = key in target;\n      const result = Reflect.deleteProperty(target, key);\n\n      if (hadKey) {\n        trigger(target, key);\n\n        // Call custom onDelete handler if provided\n        if (options.onDelete && typeof key !== 'symbol') {\n          options.onDelete.call(target, key);\n        }\n      }\n\n      return result;\n    }\n  };\n\n  const proxy = new Proxy(target, handler);\n\n  // Store the proxy to prevent creating multiple proxies for the same object\n  reactiveMap.set(target, proxy);\n\n  return proxy;\n}\n\n/**\n * Creates a computed property that automatically tracks dependencies\n * @param {Function} getter - The getter function\n * @returns {Object} - Object with value getter\n */\nexport function computed(getter) {\n  let value;\n  let dirty = true;\n\n  // The computed object that will be returned\n  const computed = {\n    get value() {\n      // Re-compute if dirty\n      if (dirty) {\n        // Run getter to compute value\n        // The effect wrapper will track dependencies\n        value = getter();\n        dirty = false;\n      }\n      // Track that something accessed this computed value\n      track(this, 'value');\n      return value;\n    }\n  };\n\n  // Create an effect that runs the getter\n  // This effect will be triggered when dependencies change\n  effect(() => {\n    // Access the computed value to set up tracking\n    // This creates the dependency link\n    // eslint-disable-next-line no-unused-expressions\n    computed.value;\n  }, {\n    lazy: false, // Run immediately\n    computed: true,\n    scheduler: () => {\n      // When dependencies change, mark as dirty\n      if (!dirty) {\n        dirty = true;\n        // Trigger effects that depend on this computed value\n        trigger(computed, 'value');\n      }\n    }\n  });\n\n  return computed;\n}\n\nexport {effect};\n","usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/Router.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/Subscription.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/Util.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/Value.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/WeakCache.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/components/Component.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/components/ExpressionParser.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/components/IfComponent.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/components/LoopComponent.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/components/PropertyComponent.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/components/RelationComponent.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/components/ValueComponent.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/repo/veda-client/src/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
